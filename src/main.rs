mod compiler;
mod nodes;
mod ui;

/*use crate::nodes::query_node::QueryDataType;*/
use crate::ui::uwu;
use bevy::ecs::component::ComponentId;
use bevy::ecs::query::{QueryData, QueryFilter, QueryIter};
use bevy::ecs::world::FilteredEntityMut;
use bevy::prelude::*;
use bevy::reflect::func::args::Ownership;
use bevy::reflect::func::{ArgList, DynamicFunction, Return};
use bevy::reflect::{Enum, ReflectFromPtr, TypeRegistry};
use bevy::tasks::futures_lite::stream::iter;
use std::any::TypeId;
use std::collections::HashMap;
use std::fmt::{Debug, Formatter};
use std::ops::DerefMut;
use std::sync::{Arc, Mutex};

pub enum QueryDataType {
    Entity,
    Ref(Box<dyn PartialReflect>),
    Mut(Box<dyn PartialReflect>),
}

impl Clone for QueryDataType {
    fn clone(&self) -> Self {
        match self {
            QueryDataType::Entity => QueryDataType::Entity,
            QueryDataType::Ref(val) => QueryDataType::Ref(val.reflect_clone().unwrap()),
            QueryDataType::Mut(val) => QueryDataType::Mut(val.reflect_clone().unwrap()),
        }
    }
}

fn main() {
    use bevy::reflect::Tuple;
    let mut a = 10;
    let mut b = true;
    let c = (&a, &mut b);
    let d = (10, true);
    let awa = c.convert_reflect();
    //d.field(0);
    //c.field(0);
    uwu();
}

fn registry_setup() -> TypeRegistry {
    let mut registry = TypeRegistry::default();
    registry.register_type_data::<QueryIterWrapper<&Transform, ()>, ReflectRefValueReflectIter>();
    //registry.register_type_data::<QueryIterWrapper<(&Transform, &Transform), ()>, ReflectRefValueReflectIter>();
    registry
}

trait TupleReflectRefMut<'a, T, B> {
    fn convert_reflect(self) -> B;
}
impl<'a, T: Reflect> TupleReflectRefMut<'a, T, (&'a mut dyn Reflect)> for &'a mut T {
    fn convert_reflect(self) -> (&'a mut dyn Reflect) {
        self.as_reflect_mut()
    }
}
impl<'a, B0: Reflect, B1: Reflect>
    TupleReflectRefMut<'a, (B0, B1), (&'a mut dyn Reflect, &'a mut dyn Reflect)>
    for (&'a mut B0, &'a mut B1)
{
    fn convert_reflect(self) -> (&'a mut dyn Reflect, &'a mut dyn Reflect) {
        let (a, b) = self;
        (a.as_reflect_mut(), b.as_reflect_mut())
    }
}

impl<'a, B0: Reflect, B1: Reflect>
    TupleReflectRefMut<'a, (B0, B1), (&'a dyn Reflect, &'a mut dyn Reflect)>
    for (&'a B0, &'a mut B1)
{
    fn convert_reflect(self) -> (&'a dyn Reflect, &'a mut dyn Reflect) {
        let (a, b) = self;
        (a.as_reflect(), b.as_reflect_mut())
    }
}

/*impl<B0: PartialReflect, B1: PartialReflect> TupleReflectRefMut<(B0, B1), (Box<dyn PartialReflect>, Box<dyn PartialReflect>)> for (B0, B1) {
    fn convert_reflect(self) -> (Box<dyn PartialReflect>, Box<dyn PartialReflect>) {
        (Box::new(self.0).into_partial_reflect(), Box::new(self.1).into_partial_reflect())
    }
}*/

/*#[reflect_trait]
trait ValueReflectIter {
    fn next_uwu(&mut self) -> Option<Box<dyn Reflect>>;
}

impl<T: Iterator<Item = I>, I: Reflect> ValueReflectIter for T {
    fn next_uwu(&mut self) -> Option<Box<dyn Reflect>> {
        <Self as Iterator>::next(self).map(|a| Box::new(a).into_reflect())
    }
}*/

/*#[reflect_trait]
trait ValueReflectIter {
    fn next_uwu(&mut self) -> Option<Value>;
}

impl<T: Iterator<Item = Value>> ValueReflectIter for T {
    fn next_uwu(&mut self) -> Option<Value> {
        <Self as Iterator>::next(self)
    }
}
*/
#[derive(Reflect)]
pub struct ValueReflectIterThing {
    #[reflect(ignore)]
    internal: Option<Box<dyn Iterator<Item = Value>>>,
}
unsafe impl Send for ValueReflectIterThing {}
unsafe impl Sync for ValueReflectIterThing {}

trait RefValueReflectIter<'a> {
    fn next_owo(&mut self) -> Option<&'a dyn Reflect>;
}
#[doc = " A type generated by the #[reflect_trait] macro for the `RefValueReflectIter` trait.\n\n This allows casting from `dyn Reflect` to `dyn RefValueReflectIter`."]
#[derive(::core::clone::Clone)]
struct ReflectRefValueReflectIter<'a> {
    get_func:
        fn(&dyn bevy::reflect::Reflect) -> ::core::option::Option<&dyn RefValueReflectIter<'a>>,
    get_mut_func: fn(
        &mut dyn bevy::reflect::Reflect,
    ) -> ::core::option::Option<&mut dyn RefValueReflectIter<'a>>,
    get_boxed_func: fn(
        bevy::reflect::__macro_exports::alloc_utils::Box<dyn bevy::reflect::Reflect>,
    ) -> ::core::result::Result<
        bevy::reflect::__macro_exports::alloc_utils::Box<dyn RefValueReflectIter<'a>>,
        bevy::reflect::__macro_exports::alloc_utils::Box<dyn bevy::reflect::Reflect>,
    >,
}
impl<'b> ReflectRefValueReflectIter<'b> {
    #[doc = " Downcast a `&dyn Reflect` type to `&dyn RefValueReflectIter`.\n\n If the type cannot be downcast, `None` is returned."]
    pub fn get<'a>(
        &self,
        reflect_value: &'a dyn bevy::reflect::Reflect,
    ) -> ::core::option::Option<&'a dyn RefValueReflectIter<'b>> {
        (self.get_func)(reflect_value)
    }
    #[doc = " Downcast a `&mut dyn Reflect` type to `&mut dyn RefValueReflectIter`.\n\n If the type cannot be downcast, `None` is returned."]
    pub fn get_mut<'a>(
        &self,
        reflect_value: &'a mut dyn bevy::reflect::Reflect,
    ) -> ::core::option::Option<&'a mut dyn RefValueReflectIter<'b>> {
        (self.get_mut_func)(reflect_value)
    }
    #[doc = " Downcast a `Box<dyn Reflect>` type to `Box<dyn RefValueReflectIter>`.\n\n If the type cannot be downcast, this will return `Err(Box<dyn Reflect>)`."]
    pub fn get_boxed(
        &self,
        reflect_value: bevy::reflect::__macro_exports::alloc_utils::Box<dyn bevy::reflect::Reflect>,
    ) -> ::core::result::Result<
        bevy::reflect::__macro_exports::alloc_utils::Box<dyn RefValueReflectIter<'b>>,
        bevy::reflect::__macro_exports::alloc_utils::Box<dyn bevy::reflect::Reflect>,
    > {
        (self.get_boxed_func)(reflect_value)
    }
}
impl<'a, T: RefValueReflectIter<'a> + bevy::reflect::Reflect> bevy::reflect::FromType<T>
    for ReflectRefValueReflectIter<'a>
{
    fn from_type() -> Self {
        Self {
            get_func: |reflect_value| {
                <dyn bevy::reflect::Reflect>::downcast_ref::<T>(reflect_value)
                    .map(|value| value as &dyn RefValueReflectIter<'a>)
            },
            get_mut_func: |reflect_value| {
                <dyn bevy::reflect::Reflect>::downcast_mut::<T>(reflect_value)
                    .map(|value| value as &mut dyn RefValueReflectIter<'a>)
            },
            get_boxed_func: |reflect_value| {
                <dyn bevy::reflect::Reflect>::downcast::<T>(reflect_value).map(|value| {
                    value
                        as bevy::reflect::__macro_exports::alloc_utils::Box<
                            dyn RefValueReflectIter<'a>,
                        >
                })
            },
        }
    }
}

impl<'a, T: Iterator<Item = &'a I>, I: Reflect> RefValueReflectIter<'a> for T {
    fn next_owo(&mut self) -> Option<&'a dyn Reflect> {
        <Self as Iterator>::next(self).map(|a| a.as_reflect())
    }
}

#[derive(Reflect, Clone)]
pub struct QueryIterWrapper<'b, 'c, D: QueryData, E: QueryFilter> {
    #[reflect(ignore)]
    query: Option<Arc<Mutex<QueryIter<'b, 'c, D, E>>>>,
}

unsafe impl<'w, 'c, D: QueryData, E: QueryFilter> Send for QueryIterWrapper<'w, 'c, D, E> {}

unsafe impl<'w, 'c, D: QueryData, E: QueryFilter> Sync for QueryIterWrapper<'w, 'c, D, E> {}

impl<'b, 'c, D: QueryData, E: QueryFilter> Iterator for QueryIterWrapper<'b, 'c, D, E> {
    type Item = D::Item<'b>;

    fn next(&mut self) -> Option<Self::Item> {
        self.query.as_mut()?.lock().unwrap().next()
    }
}
/*
/*impl<'a, 'b, E: QueryFilter, Q: QueryData> ReflectIterWrapper<Q::Item<'a>> for QueryIterWrapper<'a, 'b, Q, E>
{
    fn iter(&self) -> &dyn Iterator<Item=Q::Item<'a>> {
        self.query.as_ref().unwrap().iter()
    }

    fn iter_mut(&mut self) -> &mut dyn Iterator<Item=Q::Item<'a>> {
        self.query.as_mut().unwrap().iter_mut()
    }
}
*/
impl<T: Iterator> ReflectIterWrapper<T> for T {
    fn iter(&self) -> &dyn Iterator<Item=T::Item> {
        self.iter()
    }

    fn iter_mut(&mut self) -> &mut dyn Iterator<Item=T::Item> {
        self.iter_mut()
    }
}


pub trait ReflectIterWrapper<T: Iterator> {
    fn iter(&self) -> &dyn Iterator<Item = T::Item>;
    fn iter_mut(&mut self) -> &mut dyn Iterator<Item = T::Item>;
}

#[doc = " A type generated by the #[reflect_trait] macro for the `ReflectIterWrapper` trait.\n\n This allows casting from `dyn Reflect` to `dyn ReflectIterWrapper`."]
#[derive(::core::clone::Clone)]
pub struct ReflectReflectIterWrapper<T: Iterator> {
    get_func: fn(&dyn bevy::reflect::Reflect) -> ::core::option::Option<&dyn ReflectIterWrapper<T>>,
    get_mut_func:
        fn(&mut dyn bevy::reflect::Reflect) -> ::core::option::Option<&mut dyn ReflectIterWrapper<T>>,
    get_boxed_func: fn(
        bevy::reflect::__macro_exports::alloc_utils::Box<dyn bevy::reflect::Reflect>,
    ) -> ::core::result::Result<
        bevy::reflect::__macro_exports::alloc_utils::Box<dyn ReflectIterWrapper<T>>,
        bevy::reflect::__macro_exports::alloc_utils::Box<dyn bevy::reflect::Reflect>,
    >,
}
impl<T: Iterator> ReflectReflectIterWrapper<T> {
    #[doc = " Downcast a `&dyn Reflect` type to `&dyn ReflectIterWrapper`.\n\n If the type cannot be downcast, `None` is returned."]
    pub fn get<'a>(
        &self,
        reflect_value: &'a dyn bevy::reflect::Reflect,
    ) -> ::core::option::Option<&'a dyn ReflectIterWrapper<T>> {
        (self.get_func)(reflect_value)
    }
    #[doc = " Downcast a `&mut dyn Reflect` type to `&mut dyn ReflectIterWrapper`.\n\n If the type cannot be downcast, `None` is returned."]
    pub fn get_mut<'a>(
        &self,
        reflect_value: &'a mut dyn bevy::reflect::Reflect,
    ) -> ::core::option::Option<&'a mut dyn ReflectIterWrapper<T>> {
        (self.get_mut_func)(reflect_value)
    }
    #[doc = " Downcast a `Box<dyn Reflect>` type to `Box<dyn ReflectIterWrapper>`.\n\n If the type cannot be downcast, this will return `Err(Box<dyn Reflect>)`."]
    pub fn get_boxed(
        &self,
        reflect_value: bevy::reflect::__macro_exports::alloc_utils::Box<dyn bevy::reflect::Reflect>,
    ) -> ::core::result::Result<
        bevy::reflect::__macro_exports::alloc_utils::Box<dyn ReflectIterWrapper<T>>,
        bevy::reflect::__macro_exports::alloc_utils::Box<dyn bevy::reflect::Reflect>,
    > {
        (self.get_boxed_func)(reflect_value)
    }
}
impl<T: ReflectIterWrapper<T> + bevy::reflect::Reflect + Iterator> bevy::reflect::FromType<T>
    for ReflectReflectIterWrapper<T>
{
    fn from_type() -> Self {
        Self {
            get_func: |reflect_value| {
                <dyn bevy::reflect::Reflect>::downcast_ref::<T>(reflect_value)
                    .map(|value| value as &dyn ReflectIterWrapper<T>)
            },
            get_mut_func: |reflect_value| {
                <dyn bevy::reflect::Reflect>::downcast_mut::<T>(reflect_value)
                    .map(|value| value as &mut dyn ReflectIterWrapper<T>)
            },
            get_boxed_func: |reflect_value| {
                <dyn bevy::reflect::Reflect>::downcast::<T>(reflect_value).map(|value| {
                    value
                        as bevy::reflect::__macro_exports::alloc_utils::Box<dyn ReflectIterWrapper<T>>
                })
            },
        }
    }
}*/

#[derive(Debug)]
pub enum Value {
    Mut(*mut dyn PartialReflect),
    Ref(*const dyn PartialReflect),
    Box(Box<dyn PartialReflect>),
    List(Vec<Value>),
}

// What we do is simple
// We take our query -> a buncha *mut or *const dyn PartialReflect
// We put that in a Value::List(Vec<Value>>)
// We add an instruction to be able to get a value from that list
// So we would have a node that can deconstruct a tuple basically
// Maybe we could use the existing breakdown for it?
// Let's start with just not doing that though and have a TupleBreakdown node
// OH we can use the existing RefField or MutField instructions, match on
// if the value is a List and in that case just get the thing from the vec
// and then return it.

impl Clone for Value {
    fn clone(&self) -> Self {
        match self {
            Value::Mut(val) => Value::Mut(val.clone()),
            Value::Ref(val) => Value::Ref(val.clone()),
            Value::Box(val) => Value::Box(val.reflect_clone().unwrap()),
            Value::List(val) => Value::List(val.clone()),
        }
    }
}

#[derive(Debug)]
pub enum Bytecode {
    Pop,
    Push(Value),
    Dup(usize),
    Ref(usize),
    Mut(usize),
    DupField(usize, usize),
    RefField(usize, usize),
    MutField(usize, usize),
    ListBreakdown(usize),
    Call(DynamicFunction<'static>),
    Query(QueryWrapper),
    IterRef,
    NextMut,
    Apply(usize),
    Jump(usize),
}

pub struct QueryWrapper {
    queries: Vec<QueryDataType>,
}
impl QueryWrapper {
    pub fn new<'w>(queries: Vec<QueryDataType>) -> Self {
        QueryWrapper { queries }
    }
}
impl Debug for QueryWrapper {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.write_str("QueryWrapper")
    }
}

impl Bytecode {
    pub fn run(world: &mut World, bytecode: Vec<Bytecode>) {
        let mut map: HashMap<TypeId, ComponentId> = HashMap::default();
        for c in world.components().iter_registered() {
            map.insert(c.type_id().unwrap(), c.id());
        }
        let type_registry = world.get_resource::<AppTypeRegistry>().unwrap().clone();
        let mut stack = vec![];
        let mut potentially_garbage_data = vec![];
        let mut potentially_garbage_data_2 = vec![];
        let mut ip = 0;
        println!("bytecode: {:#?}", bytecode);
        loop {
            println!("stack: {:?}", stack);
            let Some(bytecode) = bytecode.get(ip) else {
                break;
            };
            //println!("stack: {:?}", stack);
            match bytecode {
                Bytecode::Pop => {
                    stack.pop().unwrap();
                }
                Bytecode::Push(value) => stack.push(value.clone()),
                Bytecode::Dup(index) => {
                    stack.push(stack.get(*index).unwrap().clone());
                }
                Bytecode::Call(function) => {
                    println!("calling functgion");
                    let mut args = ArgList::new();

                    let mut counts = 0;
                    for count in function.arg_count().iter() {
                        if counts < count {
                            counts = count;
                        }
                    }
                    let info = function.info();

                    for arg in info.signatures()[0].args() {
                        match stack.pop().unwrap() {
                            Value::Mut(mut_val) => {
                                args.push_mut(unsafe { &mut *mut_val });
                            }
                            Value::Ref(ref_val) => {
                                args.push_ref(unsafe { &*ref_val });
                            }
                            Value::Box(val) => match arg.ownership() {
                                Ownership::Ref => {
                                    potentially_garbage_data.push(Box::leak(val) as *const _ as *mut dyn PartialReflect);
                                    args.push_ref(unsafe {
                                        &*potentially_garbage_data.last().unwrap().clone()
                                    });
                                }
                                Ownership::Mut => {
                                    potentially_garbage_data.push(Box::leak(val) as *const _ as *mut dyn PartialReflect);
                                    args.push_mut(unsafe {
                                        &mut *potentially_garbage_data.last().unwrap().clone()
                                    });
                                }
                                Ownership::Owned => {
                                    args.push_boxed(val);
                                }
                            },
                            Value::List(_) => todo!(),
                        }
                    }
                    let ret = function.call(args).unwrap();
                    match ret {
                        Return::Owned(ret) => {
                            stack.push(Value::Box(ret));
                        }
                        Return::Ref(ret) => {
                            stack.push(Value::Ref(ret));
                        }
                        Return::Mut(mutable) => {
                            stack.push(Value::Mut(mutable));
                        }
                    }
                }
                Bytecode::RefField(_, _) => todo!(),
                Bytecode::MutField(stack_pos, field) => {
                    let field = match stack.get_mut(*stack_pos).unwrap() {
                        Value::Mut(val) => {
                            let mut s = unsafe { &mut **val }.reflect_mut().as_struct().unwrap();
                            let field = s.field_at_mut(*field).unwrap() as *mut dyn PartialReflect;
                            field
                        }
                        Value::Ref(_) => unreachable!(),
                        Value::Box(val) => {
                            let mut s = val.reflect_mut().as_struct().unwrap();
                            let field = s.field_at_mut(*field).unwrap() as *mut dyn PartialReflect;
                            field
                        }
                        Value::List(_) => todo!(),
                    };
                    stack.push(Value::Mut(field));
                }
                Bytecode::Ref(_) => todo!(),
                Bytecode::Mut(_) => todo!(),
                Bytecode::DupField(_, _) => {}
                Bytecode::Apply(field) => {
                    let applier = stack.pop().unwrap();
                    let mut receiver = stack.pop().unwrap();
                    match &mut receiver {
                        Value::Mut(_) => todo!(),
                        Value::Ref(_) => unreachable!(),
                        Value::Box(val) => {
                            let mut s = val.reflect_mut().as_struct().unwrap();
                            let applier = match applier {
                                Value::Mut(_) => unreachable!(),
                                Value::Ref(_) => unreachable!(),
                                Value::Box(val) => val,
                                Value::List(_) => todo!(),
                            };
                            s.field_at_mut(*field)
                                .unwrap()
                                .apply(applier.as_partial_reflect());
                        }
                        Value::List(_) => todo!(),
                    }
                    stack.push(receiver);
                }
                Bytecode::IterRef => todo!(),
                Bytecode::NextMut => {
                    let mut value_to_iter = stack.last_mut().unwrap();
                    let value_to_iter = match &mut value_to_iter {
                        Value::Mut(val) => unsafe { val.as_mut().unwrap() },
                        Value::Box(val) => val.deref_mut(),
                        Value::Ref(_) => unreachable!(),
                        Value::List(_) => todo!(),
                    };
                    let value_to_iter = value_to_iter.try_as_reflect_mut().unwrap();
                    let value_to_iter = value_to_iter
                        .downcast_mut::<ValueReflectIterThing>()
                        .unwrap();
                    if let Some(value) = value_to_iter.internal.as_mut().unwrap().next() {
                        println!("has next");
                        ip += 1;
                        stack.push(value);
                    }
                }
                Bytecode::Query(QueryWrapper { queries }) => {
                    let queries = queries.clone();
                    let mut query_builder = QueryBuilder::<FilteredEntityMut>::new(world);
                    for val in &queries {
                        match val {
                            QueryDataType::Entity => {
                                todo!()
                            }
                            QueryDataType::Ref(val) => {
                                query_builder.ref_id(
                                    *map.get(
                                        &val.try_as_reflect()
                                            .unwrap()
                                            .reflect_type_info()
                                            .type_id(),
                                    )
                                    .unwrap(),
                                );
                            }
                            QueryDataType::Mut(val) => {
                                query_builder.mut_id(
                                    *map.get(
                                        &val.try_as_reflect()
                                            .unwrap()
                                            .reflect_type_info()
                                            .type_id(),
                                    )
                                    .unwrap(),
                                );
                            }
                        }
                    }
                    let query_state = query_builder.build();
                    potentially_garbage_data_2.push(query_state);
                    let query_state: &mut QueryState<FilteredEntityMut> = unsafe {
                        std::mem::transmute(potentially_garbage_data_2.last_mut().unwrap())
                    };

                    //TODO This is highly unsafe, we need to enforce that you can't have two queries with mutable data the same time in the compiler.
                    let world = unsafe {
                        let w = world as *mut World;
                        &mut *w
                    };
                    let type_registry = type_registry.clone();
                    let map = map.clone();
                    let awa = query_state.iter_mut(world).map(move |mut a| {
                        let binding = type_registry.clone();
                        let type_registry = binding.read();
                        let mut values = vec![];
                        for data in queries.iter() {
                            let value = match data {
                                QueryDataType::Entity => todo!(),
                                QueryDataType::Ref(val) => {
                                    let type_id =
                                        val.try_as_reflect().unwrap().reflect_type_info().type_id();
                                    let a = a.get_by_id(*map.get(&type_id).unwrap()).unwrap();
                                    let reflect_data = type_registry.get(type_id).unwrap();
                                    let reflect_from_ptr =
                                        reflect_data.data::<ReflectFromPtr>().unwrap();
                                    let reflect = unsafe {
                                        reflect_from_ptr.as_reflect(a).as_partial_reflect()
                                    }
                                        as *const dyn PartialReflect;
                                    Value::Ref(reflect)
                                }

                                QueryDataType::Mut(val) => {
                                    let type_id =
                                        val.try_as_reflect().unwrap().reflect_type_info().type_id();
                                    let mut a =
                                        a.get_mut_by_id(*map.get(&type_id).unwrap()).unwrap();
                                    let reflect_data = type_registry.get(type_id).unwrap();
                                    let reflect_from_ptr =
                                        reflect_data.data::<ReflectFromPtr>().unwrap();
                                    let reflect = unsafe {
                                        reflect_from_ptr
                                            .as_reflect_mut(a.as_mut())
                                            .as_partial_reflect_mut()
                                    }
                                        as *mut dyn PartialReflect;
                                    Value::Mut(reflect)
                                }
                            };
                            values.push(value);
                        }
                        Value::List(values)
                    });
                    let value = Box::new(ValueReflectIterThing {
                        internal: Some(Box::new(awa)),
                    });
                    stack.push(Value::Box(value));
                }
                Bytecode::Jump(jump_position) => {
                    ip = *jump_position;
                    continue;
                }
                Bytecode::ListBreakdown(list_breakdown) => {
                    let value = stack.pop().unwrap();
                    let val = match value {
                        Value::List(val) => val,
                        _ => unreachable!(),
                    };
                    for val in val {
                        stack.push(val);
                    }
                }
            }
            ip += 1;
        }
        for garbage_data in potentially_garbage_data {
            drop(unsafe { Box::from_raw(garbage_data) });
        }
    }
}
